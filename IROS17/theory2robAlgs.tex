

\section{Position Control of Two Robots Using Wall Friction}\label{sec:PostionControl2Robots}


\begin{figure}
\centering
\begin{overpic}[width=0.47\columnwidth]{twoRobotRegionH.pdf}\end{overpic}
\begin{overpic}[width=0.47\columnwidth]{twoRobotRegionV.pdf}\end{overpic}
\caption{\label{fig:TwoRegions}
Boundary interaction is used to change relative position. Each robot gets the same control input. 
(left) If robot 2 hits the bottom wall before robot 1 reaches a wall, robot 2 can reach anywhere along the green line, and  robot 1 can move to anywhere in the shaded area. 
(right) Similarly, if robot 2 hits the right wall before robot 1 reaches a wall, robot 2 can reach anywhere along the green line, and  robot 1 can move to anywhere in the shaded area. 
} \vspace{-1em}
\end{figure}


\begin{figure*}
\centering
\renewcommand{\figwid}{0.67\columnwidth}
{\begin{overpic}[width =\figwid]{RegionMove1.pdf}
\end{overpic}
\begin{overpic}[width =\figwid]{RegionMove2.pdf}
\end{overpic}
\begin{overpic}[width =\figwid]{RegionMove3.pdf}
\end{overpic}
}\\

\caption{\label{fig:regionMove}{Workspace and $\Delta$ configuration space for three sets of robot configurations with the same final goal. The red square represents the starting $\Delta x$ and $\Delta y$ and the green circle represents the goal $\Delta x$ and $\Delta y$. The green rectangle illustrates one move reachable $\Delta x$ and $\Delta y$ by horizontal walls and the blue rectangle illustrates the vertical walls reachable region.
}
\vspace{-1em}
}
\end{figure*}


\begin{figure*}
\centering
\renewcommand{\figwid}{0.5\columnwidth}
{\begin{overpic}[width =\figwid]{epsilonMin.pdf}%\put(20,20){$\epsilon = 0.001$}
\put(20, 3.1){{\scriptsize$\swarrow$}~$\epsilon = 0.001$}
\end{overpic}
\begin{overpic}[width =\figwid]{epsilonMed.pdf}%\put(20,20){$\epsilon = 0.05$}
\put(20, 4){{\scriptsize$\updownarrow$}~$\epsilon = 0.05$}
\end{overpic}
\begin{overpic}[width =\figwid]{epsilonMax.pdf}%\put(20,20){$\epsilon = 0.1$}
\put(20, 5){{\Large$\updownarrow$}~$\epsilon = 0.1$}
\end{overpic}
}\\
\caption{\label{fig:epsilon}{Changing the minimum spacing $\epsilon$ changes the path.   $\epsilon$ is the minimum spacing between two robots and the minimum separation from the boundaries.}
\vspace{-1em}
}
\end{figure*}



\begin{figure}
\centering
\begin{overpic}[width=0.5\columnwidth]{Reflection.pdf}\end{overpic}
\caption{\label{fig:reflection}
If the goal configuration can be reached in three moves, the first move makes one particle hit a wall, the second move adjusts the relative spacing error $\Delta e$ to zero, and the third move takes the particles to their final positions. 
The second move cannot be shortened, so optimization depends on choosing the location where the robot hits the wall. 
 Since the shortest distance between two points is a straight line, reflecting the goal position across the boundary wall and plotting a straight line gives the optimal hit location.
} \vspace{-1em}
\end{figure}
\begin{figure*}
\renewcommand{\figwid}{0.4\columnwidth}
{\begin{overpic}[width =\figwid]{story1mov0.pdf}\put(10,10){Start}
\put(10,85){a)}
\put(30,70){$r_1$}
\put(48,88){$g_1$}
\put(65,17){$r_2$}
\put(87,52){$g_2$}
\end{overpic}
\begin{overpic}[width =\figwid]{story1move.pdf}\put(10,10){Move 1}
\put(110,50){If $(\Delta e.x, \Delta e.y) = (0,0)$, only one move is needed}
\end{overpic}
}\\

\vspace{-0.75em}
{\begin{overpic}[width =\figwid]{story3Moves1.pdf}\put(10,10){Start}
\put(10,85){b)}
\put(28,70){$r_1$}
\put(50,80){$g_1$}
\put(62,15){$r_2$}
\put(30,22){$g_2$}
\end{overpic}
\begin{overpic}[width =\figwid]{story3Moves2.pdf}\put(10,10){Move 1}
\end{overpic}
\begin{overpic}[width =\figwid]{story3Moves3.pdf}\put(10,10){Move 2}
\end{overpic}
\begin{overpic}[width =\figwid]{story3Moves4.pdf}\put(10,10){Move 3}
\end{overpic}
%\begin{overpic}[width =\figwid]{s5}\put(50,80){Move 4}
%\end{overpic}
%\begin{overpic}[width =\figwid]{S6.pdf}\put(50,80){Move 5}
%\end{overpic}
}\\

\vspace{-0.75em}
{
\begin{overpic}[width =\figwid]{story5move1.pdf}\put(10,10){Move 1}
\put(10,85){c)}
\put(28,70){$r_1$}
\put(62,28){$g_1$}
\put(87,50){$r_2$}
\put(30,22){$g_2$}
\end{overpic}
\begin{overpic}[width =\figwid]{story5move2.pdf}\put(10,10){Move 2}
\end{overpic}
\begin{overpic}[width =\figwid]{story5move3.pdf}\put(10,10){Move 3}
\end{overpic}
\begin{overpic}[width =\figwid]{story5move4.pdf}\put(10,10){Move 4}
\end{overpic}
\begin{overpic}[width =\figwid]{story5move5.pdf}\put(10,10){Move 5}
\end{overpic}
}\\

\vspace{-0.75em}
%\vspace{1em}
{
\begin{overpic}[width =\figwid]{story7move1.pdf}\put(50,80){Move 1}
\put(10,85){d)}
\put(25,30){$r_1$}
\put(89,70){$g_1$}
\put(67,20){$r_2$}
\put(28,75){$g_2$}
\end{overpic}
\begin{overpic}[width =\figwid]{story7move2.pdf}\put(50,80){Move 2}
\end{overpic}
\begin{overpic}[width =\figwid]{story7move5.pdf}\put(50,80){Move 4}
\end{overpic}
\begin{overpic}[width =\figwid]{story7move6.pdf}\put(50,80){Move 6}
\end{overpic}
\begin{overpic}[width =\figwid]{story7move7.pdf}\put(50,80){Move 7}
\end{overpic}
}\\

\vspace{-0.75em}
{
\begin{overpic}[width =\figwid]{storySame1.pdf}\put(50,80){Move 1}
\put(10,85){e)}
\put(15,35){$r_1,g_2$}
\put(65,35){$r_2,g_1$}
\end{overpic}
\begin{overpic}[width =\figwid]{storySame2.pdf}\put(50,80){Move 2}
\end{overpic}
\begin{overpic}[width =\figwid]{storySame3.pdf}\put(50,80){Move 3}
\end{overpic}
\begin{overpic}[width =\figwid]{storySame4.pdf}\put(50,80){Move 4}
\end{overpic}
\begin{overpic}[width =\figwid]{storySame5.pdf}\put(50,80){Move 5}
\end{overpic}
}\\

\vspace{-0.75em}
{
\begin{overpic}[width =\figwid]{storyWorst1.pdf}\put(60,10){Move 1}
\put(10,85){f)}
\put(15,10){$r_1,g_2$}
\put(65,88){$r_2,g_1$}
\end{overpic}
\begin{overpic}[width =\figwid]{storyWorst2.pdf}\put(60,10){Move 2}
\end{overpic}
\begin{overpic}[width =\figwid]{storyWorst4.pdf}\put(60,10){Move 4}
\end{overpic}
\begin{overpic}[width =\figwid]{storyWorst6.pdf}\put(60,10){Move 6}
\end{overpic}
\begin{overpic}[width =\figwid]{storyWorst7.pdf}\put(60,10){Move 7}
\end{overpic}
}\\

%\vspace{-0.75em}
%{
%\begin{overpic}[width =\figwid]{storyCorner1.pdf}\put(50,80){Move 1}
%\end{overpic}
%\begin{overpic}[width =\figwid]{storyCorner2.pdf}\put(50,80){Move 2}
%\end{overpic}
%%\begin{overpic}[width =\figwid]{storyCorner3.pdf}\put(50,80){Move 3}
%%\end{overpic}
%\begin{overpic}[width =\figwid]{storyCorner4.pdf}\put(50,80){Move 4}
%\end{overpic}
%\begin{overpic}[width =\figwid]{storyCorner5.pdf}\put(50,80){Move 5}
%\end{overpic}
%}\\

\vspace{-1em}
\caption{\label{fig:shapeControlMathematica1}{Frames from an implementation of Alg.\ \ref{alg:optimalAlg}: two robot positioning using walls with infinite friction. 
Robot start positions are shown by a square, and goal positions by a circle.  Dashed lines show the shortest route if robots could be controlled independently.  Solid arrows show path given by  Alg.\ \ref{alg:optimalAlg}.
Online demonstration and source code at \cite{Shahrokhi2015mathematicaParticle}.
%The bottom row shows an extreme case where the robots must switch position.
}
\vspace{-1em}
}
\end{figure*}

\begin{figure*}
\centering
\renewcommand{\figwid}{2\columnwidth}
{\begin{overpic}[width =\figwid]{contourPlots.pdf}%\put(20,20){$\epsilon = 0.001$}
\end{overpic}
}\\
\caption{\label{fig:contourPlots}{Starting positions of robots $1$ and $2$ and goal position of  robot $2$ are fixed, and 
 the contour plots calculate the distance if robot $1$'s goal position is varied in $x$ and $y$. The second row shows the number of moves required for the same configurations.}
\vspace{-1em}
}
\end{figure*}


Alg.~\ref{alg:Wallup} uses wall-friction to arbitrarily position two robots in a rectangular workspace. This algorithm introduces concepts that will be used for multi-robot positioning. Fig.~\ref{fig:shapeControlMathematica1} shows a Mathematica implementation of the algorithm, and is useful as a visual reference for the following description.

Assume two robots are initialized at $r_1$ and $r_2$ with corresponding goal destinations $g_1$ and $g_2$. 
We can exploit symmetry in the solution by labeling the leftmost  (or, if they have the same $x$ coordinate, the topmost) robot $r_1$.  If $r_1$ is not also the topmost robot, we mirror the coordinate frame across the right wall. To give an example to understand mirroring, consider the two starting positions, $r_1 =  (0.2, 0.2) $ and $r_2 = (0.8, 0.8)$. Because the leftmost robot is not the topmost robot, we mirror the coordinate frame giving $r_1 = (0.2, 0.8)$ and $r_2 = (0.8,0.2)$. We do this to reuse the main algorithm's logic and after the path is found, we undo the mirrorring to the output path. Similarly, we exploit rotational symmetry and assume the command pushes a robot to hit the top wall. If a different wall is selected, we rotate the coordinate frame by 90$^{\circ}$ , 180$^{\circ}$  or 270$^{\circ}$ counterclockwise to get other walls paths and translate the path after the algorithm returns the path for the rotated coordinate frame.

Denote the current positions of the robots  $r_1$ and $r_2$. 
Values $.x$ and $.y$ denote the $x$ and $y$ coordinates, i.e., $r_1.x$ and $r_1.y$ denote the $x$ and $y$ locations of $r_1$. 
The algorithm assigns a global control input at every instance.
The goal is to adjust the error in both coordinates,
 $\Delta e =(\Delta e.x, \Delta e.y) =\Delta g - \Delta r = (g_2-g_1)- (s_2-s_1)$to $(0,0)$ using a shared global control input. 
 %This algorithm exploits the position-dependent friction model \eqref{eq:frictionmodel}.
 %employing the assumption we have made earlier about the walls' friction. 
Our algorithm uses a A* like method of dynamic search to find the shortest path in each move. The base case occurs when $\Delta e= (0,0)$. In this base case, the shortest path is a straight line between current position of each robot to its goal position, see Fig. \ref{fig:shapeControlMathematica1} a.  
If  $\Delta e\neq (0,0)$, we consult the two-move reachable sets shown in Fig.~\ref{fig:regionMove}. If a robot is touching a wall, the other robot can move to any position in the reachable set while the first robot is immobile. 
Two reachable sets are possible, horizontal and vertical. 
%If $(\Delta g.x, \Delta g.y)$ is in the reachable set, one robot touches a wall and the other robot zeros the error in one move. This is shown as $m_2$ in Fig. \ref{fig:reflection}. To find the best place to minimize $m_1$ and $m_3$, the touching robot's goal is reflected on that wall. The minimum distance to get to the goal in two move when the robot should touch the wall, is the straight line between the robot and the reflection of the goal position on that wall. 
If the goal configuration can be reached in three moves, the first move makes one particle hit a wall, the second move adjusts the relative spacing error $\Delta e$ to zero, and the third move takes the particles to their final positions. 
The second move cannot be shortened, so optimization depends on choosing the location where the robot hits the wall. 
 Since the shortest distance between two points is a straight line, reflecting the goal position across the boundary wall and plotting a straight line gives the optimal hit location.
That point is selected when possible, but if it makes $m_2$ reach out of the workspace, the closest point to this point where the moving robot would not get out of the workspace is selected.

If  $\Delta g$ is not in the reachable set, we choose the nearest reachable $\Delta x$ and $\Delta y$ to $\Delta g$. For simplicity in this step, we choose the straight line from the touching robot to the wall for the first move. This may cause the algorithm not to return the shortest path, but the difference is not significant. 
Alg. \ref{alg:Wallup} uses an admissible heuristic that adds the current path length to the max Euclidian distance $||g-r||$ to direct exploration by expanding favorable routes first.

Alg. \ref{alg:optimalAlg} is a dynamic search to find the shortest path by trying out collisions with all the walls. It keeps a list containing all the possible paths with their current and final position of the robots. At each iteration, the algorithm sorts all the paths in the list by their total distance plus admissible heuristic. It selects the shortest path, and calls Alg. \ref{alg:Wallup} for all the four walls. It keeps calling and sorting until the goal is reached. When the goal is reached, the algorithm returns this shortest path.
%Base case 1:  deltaX and deltaY are 0, simply move robots to final position
%Base case 2:  In 2 moves we can make both deltaX and deltaY 0, implement this move, then call Base case 1:
%
%We build a list like in an A* algorithm.  Each item in the list has 4 entries, and the list is sorted based on the first entry:
%{estimatedPathLength,  r1, r2, MOVES}
%
%MOVES is the moves that have been applied to the robots: {{x1,y1},{x2,y2}} for a two move sequence.
%r1 and r2 are the positions of robot 1 and 2 after applying MOVES to them.
%
%estimatedPathLength is the sum of the euclidean distances of MOVES + an admissible heuristic (the maximum distance of r1 or r2 from their goal positions).
%
%Our algorithm solves the positioning problem in four steps: 
%First, it adjusts $\Delta r_y , \Delta r_x$ as much as possible with the left wall.
%Second, $\Delta r_x -\Delta e_x$ is reduced to zero with the bottom wall.
%Third, if the robots were not correctly positioned relative to each other, $\Delta r_y -\Delta e_y$ is reduced to zero with the right wall.
%%First, $|\Delta r_x - \Delta e_x |$ is reduced to zero while  $\Delta r_y$ is kept constant in Alg.~\ref{alg:XControl}. 
%%Second, $|\Delta r_y - \Delta e_y |$ is reduced to zero while  $\Delta r_x$ is kept constant. % in Alg.~\ref{alg:YControl}. 
%Lastly, the robots, now correctly positioned relative to each other, are moved to their goal locations.

%In the worse case, adjusting both $\Delta r.x$ and $\Delta r.y$ needs all four steps. 
If we consider the length of each side of the square workspace as L, the worst case path length is $(\sqrt{2}+2)L$.





\begin{algorithm}
\caption{WallFrictionMoveUp($r_1,r_2,g_1,g_2,L, moves$)}\label{alg:Wallup}
\begin{algorithmic}[1]
%\scriptsize
\Require knowledge of current $(r_1,r_2)$ and goal $(g_1,g_2)$ positions of  two robots. 
$(0,0)$ is bottom corner,
 $L$ is length of the walls. 
 The array \emph{moves} is the current moves up to the current position.
 $m_1$ is the first move toward the wall or goal.
 $m_2$ is the second move adjusting $\Delta e$.
 Assume $r_1.x < r_2.x$ and $r_1.y \geq r_2.y$. If not, mirror the coordinate frame and swap the robots.
 $\epsilon $ is a small, nonzero, user-specified value.
 
\Ensure $(g_1, g_2) , (r_1, r_2)$ all at least $\epsilon$ distance from walls the goals and starting points have at least epsilon distance from each other.
\State $\Delta e = (g_2 - g_1)- (r_2- r_1)$
\State Admissible heuristic = $\max$(euclidian distance from goal)
%\State $\Delta e_x = (g_2.x - g_1.x)- (r_2.x - r_1.x)$
\If {$\Delta e = (0,0)$}
\State $m_1 = (g_2.x -  r_2.x, g_2.y - r_2.y)$
\State path $\gets$ path + $m_1$
\State Return (total distance of path, path)
\EndIf
\If {$r_2.x - r_1.x - 1 + 2 \epsilon \leq  \Delta g_x \leq  1 ~ \&\&~ r_2.y - r_1,y \leq \Delta g_y \leq  0$} %\Comment{Reachable region}
\State $m_1 = (\frac{1-r_1.y}{2-g_1.y-r_1.y} g_1.x -r_1.x, 1-r_1.y)$
\If {$r_2.x + m_1.x >L$}
\State $m_1.x = 1- r_2.x$
\EndIf
\If {$r_2.x + m_1.x <0$}
\State $m_1.x = -r_2.x$
\EndIf
\Else 
\State $m_1 = (0, 1-r_1.y)$
\State Adjust $\Delta g_x$ and $\Delta g_y$ %\Comment{To go to the nearest $\Delta g_x$ and $\Delta g_y$}
%\State $\Delta g_x = r_2.x - r_1.x - 1 + 2 \epsilon
\EndIf
\State path $\gets$ path + $m_1$
\State $r_1 = r_1 + m_1$ and $r_2 = r_2 + m_1$
\State $m_2 = (\Delta g_x - (r_2.x- r_1.x), \Delta g_y - (r_2.y-r_1.y))$
\If {Robots on each other or on the wall}
\State Add $\pm \epsilon$ to $m_2.x$
\EndIf
\State path $\gets$ path + $m_2$
%\State  $r_2 = r_2 + m_2$
\State Unmirror if necessary
\State Return(total distance of path + Admissible heuristic, path)
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{DynamicOptimalSolutionFinder($r_1,r_2,g_1,g_2,L$)}\label{alg:optimalAlg}
\begin{algorithmic}[1]
%\scriptsize
\Require knowledge of current $(r_1,r_2)$ and goal $(g_1,g_2)$ positions of  two robots. 
$(0,0)$ is bottom corner,
 $L$ is length of the walls. 
 $OptimalPathList$ is a List containing all the paths sorted by their total distance. 
\State Pop the first element in OptimalPathList
\While {We have not reached the goal in the first element}
\State Call Alg. \ref{alg:Wallup} for all the four walls.
\State Add the results to OptimalPathList
\State Sort OptimalPathList
\EndWhile
\State Return(path)
\end{algorithmic}
\end{algorithm}






