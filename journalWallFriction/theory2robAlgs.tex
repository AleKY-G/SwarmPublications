

\section{Position Control of Two Robots Using Boundary Interaction}\label{sec:PostionControl2Robots}


Alg.~\ref{alg:optimalAlg} uses non-slip contacts with walls to arbitrarily position two robots in a circular workspace. In our previous work we used a rectangular workspace. We use the same idea and algorithm here but we have to modify the algorithm to adjust it for a circular workspace.
% Fig.~\ref{fig:shapeControlMathematica1} shows a Mathematica implementation of the algorithm, and is useful as a visual reference for the following description.

Assume two robots are initialized at $s_1$ and $s_2$ with corresponding goal destinations $g_1$ and $g_2$. 
Denote the current positions of the robots  $p_1$ and $p_2$ and the current distance between the robots is $d$.
Values $.x$ and $.y$ denote the $x$ and $y$ coordinates, i.e., $p_1.x$ and $p_1.y$ denote the $x$ and $y$ locations of $p_1$. 
The algorithm assigns a uniform control input at every instance.
The goal is to move the particles to the goal positions using a shared control input. We do this by first moving them to the correct relative position and then translating the particles to the goal. The first step minimizes  
 $||\Delta g - \Delta p || = ||(g_2-g_1)- (p_2-p_1)||$. 
 
 We define a $\Delta$ configuration space as a circular shape that considers all possible $\Delta p$s. We also show the starting and ending relative distance as $\Delta s$ and $\Delta e$ in $\Delta$ configuration space in Fig.~\ref{fig:deltaSpace}. Reachable set is the part of $\Delta$ configuration space where if one robot touches a wall in a specific location, the other robot can make the required relative distance without causing touching robot to move. To compute reachable set for circular workspace, first we considered all passible hitting point locations in the workspace. 
 The set of boundary points that a robot can touch before the  other robot  touches is an arc of angle $2(\pi - \frac{\arcsin{d}}{r})$, where $d= |s_1 - s_2|$ and $r$ is the radius of the circle.
 %Here $\alpha$ is the arc of the circle that it is not possible to keep the current relative distance while one robot is touching the wall in that point and is defined by $\alpha = 2 \sin ^{-1}(d)$. 
 We define the angle between two particles as $\theta = \arctan(\frac{p_1.x-p_2.x}{p_1.y - p_2.y})$. 
 
 
\begin{figure}
\centering
\begin{overpic}[width=\columnwidth]{reachableSetCircle.pdf}\end{overpic}
\caption{\label{fig:deltaSpace}Left:  the set of points where the red robot is the first to contact the boundary are drawn with a red arc. The  set of points where the blue robot is the first to contact the boundary are drawn with a blue arc. 
The possible points for the blue and pink particles to touch the boundary is shown in blue and pink arcs. Right: When the blue particle is touching a wall (blue square) the other particle (pink square) can go anywhere in the reachable set (blue region).}
\end{figure}

\begin{figure*}
\centering
%\begin{overpic}[width=0.5\columnwidth]{startPath.pdf}\end{overpic}
\begin{overpic}[width=0.67\columnwidth]{Move1.pdf}\end{overpic}
\begin{overpic}[width=0.67\columnwidth]{Move2.pdf}\end{overpic}
\begin{overpic}[width=0.67\columnwidth]{finalPath.pdf}\end{overpic}
\caption{\label{fig:reachableSet}
Left circle shows the workspace. %, and the corresponding reachable set when blue robot is touching the wall is shown as a blue region. 
Right shows the $\Delta$ configuration space and the reachable set that is shown in red is representative of the point we need to go to get to the goal relative distance in one move.%representative of the blue and pink reachable sets shown in the workspace.
}
\end{figure*}

%\begin{figure}
%\centering
%
%\caption{\label{fig:chord}
%When the blue particle is touching a wall (blue square) the other particle (pink square) can go anywhere in the reachable set (blue region).
%}
%\end{figure}
%The algorithm works by expanding the path with the shortest estimated length.
Expanding a path means either moving directly to the goal, or pushing one robot to a wall and adjusting the relative position of the other robot.
As soon as the goal is reached, the algorithm returns this path.

There are infinite reachable sets, parameterized by first contact location $\psi$, as shown in Fig.~\ref{fig:regionMove}.
%We make the reachable sets by knowing the angle of the chord, $\psi$, shown in Fig.~\ref{fig:psigamma}. Minimum and maximum values of $\psi$ can be calculated in the following equation.
\begin{align}
 \psi \in [\theta +\frac{\sin^{-1}{d}}{2r} - \frac{\pi}{2}, \theta +\frac{\sin^{-1}{d}}{2r} - \frac{\pi}{2}]
% \psi_{\max} &= \theta -\frac{\alpha}{2} + \frac{\pi}{2}
\end{align}
$\gamma$ is half the angle of the arc that the reachable set's chord has shown in Fig.~\ref{fig:deltaSpace} and is calculated by:
\begin{align}
p_\psi &= r[\cos(\psi ), \sin(\psi )]\\
d_\perp&= 2 \abs{(s_1.p_\psi - s_2.p_\psi)}\\
\gamma &= \cos^{-1} (1-\frac{d_\perp}{r} )
\end{align}
Reachable sets with $\pi$ difference in $\psi$ value are equivalent in the  $\Delta$ configuration space, so we can plan in this space and choose to immobilize the particle closest to a wall. 

The equation for the four lines outlining the reachable set can be found as follows:
\todo{Insert the equations}
%\begin{align}
%l_1 = r{\cos{\psi_{\min}, 
%   Sin[\[Theta] + \[Alpha]/2 + \[Pi]/2 ]} - 
% 1/2 {Cos[a2 + \[Theta] + \[Alpha]/2 + \[Pi]/2], 
%   Sin[a2 + \[Theta] + \[Alpha]/2 + \[Pi]/2]}
%\end{align}
% When a particle contacts a wall, the other particle can move to any position in the reachable set while the first robot is immobile. 
%Two reachable sets are possible, horizontal and vertical. 
%Each non-slip move changes the $\Delta$ configuration space, as shown in  Fig.~\ref{fig:regionMove}.
   

 %This algorithm exploits the position-dependent friction model \eqref{eq:frictionmodel}.
 %employing the assumption we have made earlier about the walls' friction. 
 \subsection{Square workspace}
Our algorithm uses an A*-like method to find the shortest path in each move. 
If $(\Delta g.x, \Delta g.y)$ is in the reachable set, one robot touches a wall and the other robot zeros the error in one move. This is shown as $m_2$ in Fig. \ref{fig:reflection}. To find the best place to minimize $m_1$ and $m_3$, the touching robot's goal is reflected on that wall. 
The minimum distance to get to the goal in two moves when the robot should touch the wall, is the straight line between the robot and the reflection of the goal position on that wall. 
If the goal configuration can be reached in three moves, then $m_1$  makes one particle hit a wall, $m_2$ adjusts the relative spacing error $\Delta e$ to zero, and  $m_3$ takes the particles to their final positions, as shown in Fig. \ref{fig:shapeControlMathematica1}b. 
$m_2$ cannot be shortened, so optimization depends on choosing the location where the robot hits the wall. 
 Since the shortest distance between two points is a straight line, reflecting the goal position across the boundary wall and plotting a straight line gives the optimal hit location, as shown in Fig. \ref{fig:reflection}.
That point is selected when possible, but if this point would cause $m_2$ to push the moving robot out of the workspace, the hit point is translated until the moving robot will not leave the workspace. If $m_2$ causes the two particles to overlap, we add or subtract $\epsilon$ to $m_2.x$ to avoid collisions. This is shown in Fig. ~\ref{fig:epsilon} with three different $\epsilon$ values.


\begin{figure}
\centering
\begin{overpic}[width=0.47\columnwidth]{twoRobotRegionH.pdf}\end{overpic}
\begin{overpic}[width=0.47\columnwidth]{twoRobotRegionV.pdf}\end{overpic}
\caption{\label{fig:TwoRegions}
Boundary interaction is used to change the relative positions of the robots. Each robot gets the same control input. 
(left) If robot 2 hits the bottom wall before robot 1 reaches a wall, robot 2 can reach anywhere along the green line, and  robot 1 can move to anywhere in the shaded area. 
(right) Similarly, if robot 2 hits the right wall before robot 1 reaches a wall, robot 2 can reach anywhere along the green line, and  robot 1 can move to anywhere in the shaded area. 
}
\end{figure}
If  $\Delta g$ is not in the reachable set, we choose the nearest reachable $\Delta x$ and $\Delta y$ to $\Delta g$. 
%For simplicity in this step, we choose the straight line from the touching robot to the wall for the first move. This may cause the algorithm not to return the shortest path, but the difference is not significant. 


Alg.~\ref{alg:optimalAlg} uses an admissible heuristic that adds the current path length to the greatest distance from each robot to their goal. This heuristic directs exploration by expanding favorable routes first.
\begin{align}\label{eq:admissibleHeuristic}
h(\text{\emph{moves}}, r_1,r_2,g_1,g_2) =& \sum_{i=1}^{|\text{\emph{moves}}|} \norm{\text{\emph{moves}}_i}  \\
&+  \max( \norm{g_1-r_1}, \norm{g_2-r_2} ) \nonumber
\end{align}


We  exploit symmetry in the solution by labeling the leftmost (or, if they have the same $x$ coordinate, the topmost) robot $r_1$. 
 If $r_1$ is not also the topmost robot, we mirror the coordinate frame about the right boundary. 
 As an example, consider the two starting positions, $r_1 =  (0.2, 0.2) $ and $r_2 = (0.8, 0.8)$. 
  Because the leftmost robot is not the topmost robot, we mirror the coordinate frame about the right boundary giving $r_1 = (0.2, 0.8)$ and $r_2 = (0.8,0.2)$. 
 After the path is found, we undo the mirroring to the output path. 
  Similarly, we exploit rotational symmetry and assume the command pushes a robot to hit the top wall.
   If a different wall is selected, we rotate the coordinate frame by 90$^{\circ}$, 180$^{\circ}$, or 270$^{\circ}$ counterclockwise and then push the robot to hit the top wall.  After the path is found, we undo the rotation. 
   This symmetry allows us to use a single function, Alg. \ref{alg:Wallup},  for collisions with all four walls. 

\begin{algorithm}[htb]
\caption{ { \sc 2-ParticlePathFinder}($r_1,r_2,g_1,g_2,L$)}\label{alg:optimalAlg}
\begin{algorithmic}[1]
%\scriptsize
\Require knowledge of current $(r_1,r_2)$ and goal $(g_1,g_2)$ positions of  two robots. 
$(0,0)$ is bottom corner,
 $L$ is length of the walls. 
 \emph{PathList} contains all the paths sorted by their path length plus an admissible heuristic. 
 \State  \emph{PathList} $\gets \{\}$
 \State $P \gets   \{ h(\{\},r_1,r_2,g_1,g_2  ) ,\{\},r_1,r_2\} $ \Comment $P$ contains $h$, the admissible heuristic \eqref{eq:admissibleHeuristic}, the move sequence, and the current robot positions
\While {$P.r_1 \ne g_1$ \textbf{and} $P.r_2 \ne g_2$}
\For{ $\theta \in \{0^\circ, 90^\circ, 180^\circ, 270^\circ \}$ }
\State $(r_1,r_2,g_1,g_2) \gets$ {\sc Rotate}($P.r_1,P.r_2,g_1,g_2,\theta$)
\State $\{d, $ \parbox[t]{.3\linewidth}{%
 \emph{moves,}$ r_1,r_2\} \gets$\\
 {\sc  PlanMoveUp}($r_1,r_2,g_1,g_2,L, P.\text{\emph{moves}}$)}
\State $(\text{\emph{moves}}, r_1,r_2) \gets$ {\sc Rotate}(\emph{moves}$, r_1,r_2,-\theta$)
\State   {\sc Push} $\{d, \text{\emph{moves}}, r_1,r_2\} $ onto \emph{PathList}
\EndFor
\State {\sc Sort}(\emph{PathList}) \Comment sort by admissible heuristic
\State $P \gets $ {\sc Pop} first element of \emph{PathList}
\EndWhile
\State \Return \emph{moves}
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{{\sc PlanMoveUp}($r_1,r_2,g_1,g_2,L, $\emph{moves})}\label{alg:Wallup}
\begin{algorithmic}[1]
%\scriptsize
\Require knowledge of current $(r_1,r_2)$ and goal $(g_1,g_2)$ positions of  two robots. 
$(0,0)$ is bottom corner,
 $L$ is length of the walls. 
 The array \emph{moves} is the current sequence of moves up to the current position.
 Assume $r_1.x < r_2.x$ and $r_1.y \geq r_2.y$. If not, mirror the coordinate frame and swap the robots, then undo the mirroring before returning.
 $\epsilon $ is a small, nonzero, user-specified value.
 
\Ensure $(g_1, g_2) , (r_1, r_2)$ all at least $\epsilon$ distance from walls the goals and starting points have at least $\epsilon$ distance from each other.  
$m_1$ is the first move toward the wall or goal.
 $m_2$ is the second move adjusting $\Delta e$.
\State $\Delta e \gets (g_2 - g_1)- (r_2- r_1)$
\If {$\Delta e = (0,0)$} \Comment{base case}
\State $m_1  \gets g_2 -  r_2$
\State \emph{moves}$ \gets \{ \text{\emph{moves}},   m_1 \}$
\State $(r_1,r_2) \gets ${\sc ApplyMove}$(m_1,r_1,r_2)$
\State \Return $\{h(\text{\emph{moves}}, r_1,r_2,g_1,g_2), \text{\emph{moves}},r_1,r_2\}$
\EndIf
\If {$r_2.x - r_1.x - 1 + 2 \epsilon \leq  \Delta g.x \leq  1 ~\textbf{and}~r_2.y - r_1.y \leq \Delta g.y \leq  0$} \Comment{$\Delta g \in $ reachable region}
\State $m_1 \gets \left(\frac{1-r_1.y}{2-g_1.y-r_1.y} (g_1.x -r_1.x), 1-r_1.y \right)$
\If {$r_2.x + m_1.x >L$}
\State $m_1.x \gets 1- r_2.x$
%\EndIf
\Else \textbf{ if} {$r_2.x + m_1.x < 0$}  \textbf{then}
\State $m_1.x \gets -r_2.x$
\EndIf
\Else 
\State $m_1 = (0, 1-r_1.y)$
\State $\Delta g \gets $ closest reachable $(\Delta x,\Delta y)$.
%Adjust $\Delta g_x$ and $\Delta g_y$ %\Comment{To go to the nearest $\Delta g_x$ and $\Delta g_y$}
%\State $\Delta g_x = r_2.x - r_1.x - 1 + 2 \epsilon
\EndIf
\State \emph{moves}$ \gets \{ \text{\emph{moves}},   m_1\}$
\State $(r_1,r_2) \gets ${\sc ApplyMove}$(m_1,r_1,r_2)$
\State $m_2 \gets \Delta g -  (r_2- r_1)$
\If {robots on each other \textbf{or} on the wall}
\State Add $\pm \epsilon$ to $m_2.x$ to avoid collision
\EndIf
\State \emph{moves} $ \gets \{ \text{\emph{moves}},   m_2\}$
\State $(r_1,r_2) \gets ${\sc ApplyMove}$(m_2,r_1,r_2)$
\State \Return $\{h(\text{\emph{moves}}, r_1,r_2,g_1,g_2), \text{\emph{moves}},r_1,r_2\}$
\end{algorithmic}
\end{algorithm}








\begin{figure}
\centering
\begin{overpic}[width=0.5\columnwidth]{Reflection.pdf}\end{overpic}
\caption{\label{fig:reflection}
If the goal configuration can be reached in three moves, the first move makes one particle hit a wall, the second move adjusts the relative spacing error $\Delta e$ to zero, and the third move takes the particles to their final positions. 
The second move cannot be shortened, so optimization depends on choosing the location where the robot hits the wall. 
 Since the shortest distance between two points is a straight line, reflecting the goal position across the boundary wall and plotting a straight line gives the optimal hit location.
} \vspace{-1em}
\end{figure}

%\begin{figure*}
%\centering
%\renewcommand{\figwid}{0.5\columnwidth}
%{\begin{overpic}[width =\figwid]{epsilonMin.pdf}%\put(20,20){$\epsilon = 0.001$}
%\put(20, 3.1){{\scriptsize$\swarrow$}~$\epsilon = 0.001$}
%\end{overpic}
%\begin{overpic}[width =\figwid]{epsilonMed.pdf}%\put(20,20){$\epsilon = 0.05$}
%\put(20, 3.9){{\tiny$\updownarrow$}~$\epsilon = 0.05$}
%\end{overpic}
%\begin{overpic}[width =\figwid]{epsilonMax.pdf}%\put(20,20){$\epsilon = 0.1$}
%\put(20, 5){{\large$\updownarrow$}~$\epsilon = 0.1$}
%\end{overpic}
%}\\
%\caption{\label{fig:epsilon}{Changing the minimum spacing $\epsilon$ changes the path.   $\epsilon$ is the minimum spacing between two robots and the minimum separation from the boundaries.}
%\vspace{-1em}
%}
%\end{figure*}







\subsection{3D workspaces: Cylinders and Prisms}

Extending path planning to 3D is possible only if the two particles do not initially have the same $x$ and $y$ positions.
For ease of analysis, we assume the workspace boundaries extend in the $\pm z$ direction to form either right cylinders or right prisms.
If the 3D projection is at a different angle, redefine the 2D workspace as a region perpendicular to the projection.
 First, we move the closest particle to the boundary, which prevents its $z$ coordinate from changing.  
 We next apply actuation in either the $\pm z$ direction to achieve the desired $\Delta z$.
 Then the particles are actuated away from the boundary and to the appropriate $z$ positions.
 Path planning continues using Alg. XX to position the particles to the desired $x$ and $y$ positions. 
 As an example, consider Fig.~\ref{fig:zaxis} which shows a cylinder.
 The blue particle starts in the blue disk and the red particle starts in the red disk. There are two possible optimal paths shown with parallel arrows. 
Each arrow will cause one of the particles to touch the wall, enabling the other robot to move freely in the  $z$ axis to achieve the required relative position.
This can be extended to other 3D workspaces if the workspace can be locally approximated as a 3D prism or cylinder. Other workspaces may be better handled by other path planners, such as \cite{MassiveUnifromManipulation}.

\begin{figure}
\centering
\begin{overpic}[width=0.5\columnwidth]{zaxis.pdf}\end{overpic}
\caption{\label{fig:zaxis}
Extending the algorithm to position the particles in 3D.
} \vspace{-1em}
\end{figure}






